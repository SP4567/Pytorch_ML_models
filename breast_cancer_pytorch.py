# -*- coding: utf-8 -*-
"""Breast_cancer_Pytorch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jBYv1227w5DUA90ia0rqH3slwwUFjUhc
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import torch

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/data.csv")

df

df = df.drop(['id','Unnamed: 32'],axis = 1)

df.head()

df.dtypes

df.isnull().sum()

df['diagnosis'].value_counts()

sns.countplot(data = df, x = 'diagnosis')

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
df['diagnosis'] = encoder = encoder.fit_transform(df[['diagnosis']])

df.head()

df['diagnosis'].value_counts()

X = df.drop('diagnosis', axis = 1)

y = df['diagnosis'].values

X.head()

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
X = scaler.fit_transform(X)

X

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(X,y, test_size = 0.2, random_state = 42)

print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

from torch.utils.data import Dataset, DataLoader

class TabularData(Dataset):
  def __init__(self, x, y):
    super().__init__()
    self.x = torch.from_numpy(x).type(torch.float32)
    self.y = torch.from_numpy(y).type(torch.float32)
  def __len__(self):
    return len(self.x)
  def __getitem__(self, id):
    return self.x[id], self.y[id]

train = TabularData(X_train,y_train)

len(train)

train[0]

test = TabularData(X_test, y_test)

len(test)

test[0]

train_loader = DataLoader(train,batch_size = 8, shuffle = True)

class Binclr(torch.nn.Module):
  def __init__(self):
    super().__init__()
    self.layer1 = torch.nn.Linear(in_features = 30, out_features = 32)
    self.layer2 = torch.nn.Linear(in_features = 32, out_features = 16)
    self.layer3 = torch.nn.Linear(in_features = 16, out_features = 1)
    self.relu = torch.nn.ReLU()
  def forward(self, x: torch.Tensor):
    return self.layer3(self.relu(self.layer2(self.relu(self.layer1(x)))))

device = 'cuda' if torch.cuda.is_available() else 'cpu'

device

model = Binclr().to(device)

model.state_dict()

(torch.sigmoid(model(next(iter(train_loader))[0].type(torch.float32))) >= 0.5).type(torch.int)

loss = torch.nn.BCELoss()
optim = torch.optim.Adam(params = model.parameters(), lr = 0.01)

epochs = 15
for epoch in range(epochs):
  temp_loss = []
  for i,(features, target) in enumerate(train_loader):
    model.train()
    y_pred = model(features)
    y_pred = torch.sigmoid(y_pred)
    loss_fn = loss(y_pred.squeeze(), target)
    temp_loss.append(loss_fn.item())
    optim.zero_grad()
    loss_fn.backward()
    optim.step()
  print(f"Epoch {epoch} | Loss: {sum(temp_loss)/len(temp_loss)}")

y_pred = torch.sigmoid(model(torch.from_numpy(X_test).to(torch.float32))).detach().numpy()

y_pred

y_test

y_pred = (y_pred >= 0.5).astype(int).squeeze()

len(y_pred)

y_test

from sklearn.metrics import accuracy_score, confusion_matrix
score = accuracy_score(y_test, y_pred)

score*100

sns.heatmap(confusion_matrix(y_test, y_pred), fmt = '.1f', annot = True)